<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CM360 Tag Viewer</title>
  <link href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Segoe UI', sans-serif; margin: 0; display: flex; height: 100vh; background: linear-gradient(135deg, #E6F0FA 0%, #F0F6FF 100%); color: #0A1E3F; }
    #leftPanel { width: 50%; height: 100%; padding: 15px; border-right: 2px solid #0055A4; overflow: auto; display: flex; flex-direction: column; background-color: #fff; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
    #creative { flex: 1; border: 1px solid #0055A4; border-radius: 8px; padding: 10px; background-color: #F0F6FF; overflow: auto; }
    #log { width: 50%; height: 100%; padding: 20px; background-color: #F0F6FF; overflow-y: auto; }
    h3 { margin-top: 0; color: #0055A4; font-weight: 600; font-size: 1.4em; margin-bottom: 20px; }
    .pixel-check { font-size: 14px; margin: 8px 0; padding: 8px 12px; border-radius: 6px; border-left: 4px solid; background-color: #fff; }
    .fired { color: #2E7D32; font-weight: 600; border-left-color: #4CAF50; background-color: #E8F5E8; }
    .not-fired { color: #C9302C; border-left-color: #F44336; background-color: #FFEBEE; }
    .pending { color: #FF9800; border-left-color: #FF9800; background-color: #FFF3E0; }
    #backButton { margin-bottom: 12px; padding: 12px 24px; font-size: 14px; cursor: pointer; border: none; border-radius: 8px; background: linear-gradient(135deg, #0055A4 0%, #007ACC 100%); color: #fff; font-weight: 600; transition: all .3s ease; box-shadow: 0 2px 8px rgba(0,85,164,.3); }
    #backButton:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,85,164,.4); }
    .stats { background-color: #fff; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #0055A4; }
    .stats-item { display: inline-block; margin-right: 20px; font-weight: 600; }
    .fired-count { color: #2E7D32; } .pending-count { color: #FF9800; } .not-fired-count { color: #C9302C; }
    .network-log { max-height: 260px; overflow-y: auto; background-color: #fff; border: 1px solid #0055A4; border-radius: 8px; padding: 10px; margin-top: 20px; font-family: monospace; font-size: 12px; }
    .network-entry { margin: 2px 0; padding: 2px 4px; border-radius: 3px; }
    .network-success { background-color: #E8F5E8; } .network-error { background-color: #FFEBEE; }
    .network-pixel { background-color: #FFF3E0; border: 1px solid #FF9800; }
    .clear-btn { background: none; border: 1px solid #0055A4; color: #0055A4; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer; margin-top: 10px; }
    .clear-btn:hover { background-color: #0055A4; color: #fff; }

    /* ID Parser panel */
    .id-panel { background:#fff; border:1px solid #0055A4; border-radius:8px; padding:12px; margin:20px 0; }
    .id-grid { display:grid; grid-template-columns: 160px 1fr auto; gap: 8px 10px; align-items:center; }
    .id-label { font-weight:600; color:#0055A4; }
    .id-value { padding:6px 8px; background:#F0F6FF; border:1px solid #c7dcff; border-radius:6px; min-height:18px; font-family:monospace; font-size:12px; }
    .copy-btn { border:1px solid #0055A4; background:#fff; color:#0055A4; border-radius:6px; padding:4px 8px; cursor:pointer; font-size:12px; }
    .copy-btn:hover { background:#0055A4; color:#fff; }
    .hint { font-size:12px; color:#555; margin-top:8px; }
    .tiny { font-size:11px; color:#233; margin-top:8px; opacity:.8; }
  </style>
</head>
<body>
  <div id="leftPanel">
    <button id="backButton" onclick="goBack()">‚Üê Back to Index</button>
    <div id="creative"></div>
  </div>

  <div id="log">
    <h3>Pixel Tracker</h3>
    <div class="stats">
      <span class="stats-item fired-count">‚úÖ Fired: <span id="firedCount">0</span></span>
      <span class="stats-item pending-count">‚è≥ Pending: <span id="pendingCount">0</span></span>
      <span class="stats-item not-fired-count">‚ùå Not Detected: <span id="notFiredCount">0</span></span>
      <span class="stats-item" id="captureWindowLabel" title="Total capture timeout window">üïí Window: 60s</span>
    </div>

    <!-- === ID PARSER PANEL === -->
    <div class="id-panel">
      <h3 style="margin-top:0">ID Parser</h3>
      <div class="id-grid">
        <div class="id-label">Placement ID</div>
        <div class="id-value" id="placementIdValue"></div>
        <button class="copy-btn" onclick="copyText('placementIdValue')">Copy</button>

        <div class="id-label">Ad ID</div>
        <div class="id-value" id="adIdValue"></div>
        <button class="copy-btn" onclick="copyText('adIdValue')">Copy</button>

        <div class="id-label">Creative ID</div>
        <div class="id-value" id="creativeIdValue"></div>
        <button class="copy-btn" onclick="copyText('creativeIdValue')">Copy</button>
      </div>
      <div class="hint">Pulled from the tag content and any observed request URLs (keys like <code>adid</code>, <code>crid</code>/<code>creative</code>, <code>placementid</code>/<code>plid</code>).</div>
      <div class="tiny" id="idParserNotes"></div>
    </div>

    <h3>Network Activity</h3>
    <button class="clear-btn" onclick="clearNetworkLog()">Clear Log</button>
    <div id="networkLog" class="network-log"></div>
  </div>

  <script>
    // ---- Keep your vendor patterns EXACTLY as provided ----
    const expectedPixels = [
      { name: "CM360/DoubleClick", patterns: ["doubleclick.net", "googleadservices.com", "googlesyndication.com", "dcmads.js", "fls.doubleclick.net"] },
      { name: "LiveRamp", patterns: ["di.rlcdn.com", "liveramp.com"] },
      { name: "Connect", patterns: ["hrzn-nxt.com", "horizon-nxt.com"] },
      { name: "Meta/Facebook", patterns: ["facebook.com/tr", "connect.facebook.net"] },
      { name: "Google Ads", patterns: ["googleads.g.doubleclick.net", "google-analytics.com", "googletagmanager.com"] },
      { name: "DoubleVerify", patterns: ["cdn.doubleverify.com"] },
      { name: "iSpot", patterns: ["ispot.tv/"] },
      { name: "Generic Pixel", patterns: [".gif", ".png", ".jpg", "pixel", "tracking"] }
    ];

    // ---- UI state + helpers ----
    const pixelStatus = {};
    const networkLog = [];
    let networkLogElement, pixelListElement;

    // === CAPTURE WINDOW / TIMEOUT (extended by +30s) ===
    // Base 30s + extra 30s (configurable via ?extraMs=<number>)
    const params = new URLSearchParams(window.location.search);
    const BASE_CAPTURE_MS = 30000;
    const EXTRA_CAPTURE_MS = Math.max(0, parseInt(params.get('extraMs') || '30000', 10) || 0);
    const CAPTURE_TIMEOUT_MS = BASE_CAPTURE_MS + EXTRA_CAPTURE_MS; // default 60s
    const IDLE_STOP_MS = Math.max(3000, parseInt(params.get('idleMs') || '5000', 10) || 5000);
    // Update label
    (function(){ const el = document.getElementById('captureWindowLabel'); if (el) el.textContent = 'üïí Window: ' + Math.round(CAPTURE_TIMEOUT_MS/1000) + 's'; })();

    let finalizeTimer = null;
    let lastEventCount = 0;
    let lastActivityTs = Date.now();

    function bumpActivity() {
      lastEventCount++;
      lastActivityTs = Date.now();
    }

    function startCaptureWindow(onFinalize) {
      // Hard stop
      finalizeTimer = setTimeout(() => {
        try { onFinalize('timeout'); } catch(e){}
      }, CAPTURE_TIMEOUT_MS);

      // Early stop when idle (no new events for IDLE_STOP_MS)
      (function pollIdle(){
        const now = Date.now();
        if (now - lastActivityTs >= IDLE_STOP_MS) {
          clearTimeout(finalizeTimer);
          try { onFinalize('idle'); } catch(e){}
          return;
        }
        requestAnimationFrame(pollIdle);
      })();
    }

    function initializePixelTracking() {
      pixelListElement = document.getElementById("pixelList");
      networkLogElement = document.getElementById("networkLog");
      expectedPixels.forEach(pixel => {
        pixelStatus[pixel.name] = 'not-fired';
        const el = document.createElement("div");
        el.className = "pixel-check not-fired";
        el.id = `pixel-${pixel.name.replace(/[^a-zA-Z0-9]/g, '')}`;
        el.textContent = `‚ùå ${pixel.name}: Not detected`;
        pixelListElement.appendChild(el);
      });
      updateStats();
    }

    function markPixelFired(name, url) {
      if (pixelStatus[name] !== 'fired') {
        pixelStatus[name] = 'fired';
        const el = document.getElementById(`pixel-${name.replace(/[^a-zA-Z0-9]/g, '')}`);
        if (el) { el.className = "pixel-check fired"; el.textContent = `‚úÖ ${name}: Detected`; }
        logPixelDetection(name, url);
        updateStats();
      }
    }

    function markPixelPending(name) {
      if (pixelStatus[name] === 'not-fired') {
        pixelStatus[name] = 'pending';
        const el = document.getElementById(`pixel-${name.replace(/[^a-zA-Z0-9]/g, '')}`);
        if (el) { el.className = "pixel-check pending"; el.textContent = `‚è≥ ${name}: Loading...`; }
        updateStats();
      }
    }

    function updateStats() {
      const vals = Object.values(pixelStatus);
      document.getElementById('firedCount').textContent = vals.filter(s => s === 'fired').length;
      document.getElementById('pendingCount').textContent = vals.filter(s => s === 'pending').length;
      document.getElementById('notFiredCount').textContent = vals.filter(s => s === 'not-fired').length;
    }

    function logNetworkActivity(url, status, description) {
      const timestamp = new Date().toLocaleTimeString();
      networkLog.push({ timestamp, url, status, description });
      const logEntry = document.createElement('div');
      logEntry.className = `network-entry network-${status}`;
      logEntry.textContent = `[${timestamp}] ${description}: ${url}`;
      networkLogElement.appendChild(logEntry);
      networkLogElement.scrollTop = networkLogElement.scrollHeight;
      bumpActivity(); // mark activity for idle detector
      // detect after logging
      setTimeout(() => { checkPixelUrl(url); tryParseIdsFromUrl(url); }, 0);
    }

    function logPixelDetection(name, url) {
      const timestamp = new Date().toLocaleTimeString();
      networkLog.push({ timestamp, url, status: 'pixel', description: `${name} PIXEL FIRED` });
      const logEntry = document.createElement('div');
      logEntry.className = 'network-entry network-pixel';
      logEntry.textContent = `[${timestamp}] üéØ ${name} PIXEL FIRED: ${url}`;
      networkLogElement.appendChild(logEntry);
      networkLogElement.scrollTop = networkLogElement.scrollHeight;
      bumpActivity();
    }

    function clearNetworkLog() { networkLog.length = 0; networkLogElement.innerHTML = ''; }

    // ---- Smarter matching: hostname-aware + case-insensitive ----
    function checkPixelUrl(url) {
      if (!url || typeof url !== 'string') return;
      let full = "", host = "";
      try {
        const u = new URL(url, window.location.href);
        full = u.href.toLowerCase();
        host = u.hostname.toLowerCase();
      } catch { full = String(url).toLowerCase(); }
      expectedPixels.forEach(pixel => {
        const hit = pixel.patterns.some(pat => {
          const p = String(pat).toLowerCase().trim();
          if (p.includes(".") && !p.startsWith("/") && host) { // domain-like pattern
            if (host === p || host.endsWith("." + p)) return true;
          }
          return full.includes(p); // path/substring fallback
        });
        if (hit) markPixelFired(pixel.name, url);
      });
    }

    function goBack() { window.location.href = "index.html"; }
    window.goBack = goBack;

    // ---- Child-iframe instrumentation (about:blank -> same-origin) ----
    const CHILD_HOOKS_JS = `
      (function(){
        function send(kind, url, extra){ try{ parent.postMessage({kind, url, extra}, '*'); }catch(e){} }
        const _fetch = window.fetch;
        window.fetch = function(...args){
          const u = (args[0] && args[0].url) ? args[0].url : String(args[0]);
          send('fetch-init', u, {});
          return _fetch.apply(this, args).then(r => { send('fetch-done', u, {status:r.status}); return r; })
                                         .catch(err => { send('fetch-error', u, {message:err && err.message}); throw err; });
        };
        const _XHR = window.XMLHttpRequest;
        window.XMLHttpRequest = function(){
          const xhr = new _XHR(); const _open = xhr.open;
          xhr.open = function(method, url, ...rest){ xhr.__u = url; send('xhr-open', url, {method}); return _open.apply(this, [method,url,...rest]); };
          xhr.addEventListener('load',  ()=>send('xhr-done',  xhr.__u||'', {status:xhr.status}));
          xhr.addEventListener('error', ()=>send('xhr-error', xhr.__u||'', {}));
          return xhr;
        };
        if (navigator && navigator.sendBeacon){
          const _beacon = navigator.sendBeacon.bind(navigator);
          navigator.sendBeacon = function(url, data){ send('beacon', String(url||''), {}); return _beacon(url, data); };
        }
        const _append = Node.prototype.appendChild;
        Node.prototype.appendChild = function(ch){
          try{ if(ch && ch.tagName){ const u = ch.src || ch.href || ''; if(u) send('dom-append', u, {tag: ch.tagName}); } }catch(e){}
          return _append.call(this, ch);
        };
        const _setAttr = Element.prototype.setAttribute;
        Element.prototype.setAttribute = function(name, value){
          try{ if((name==='src'||name==='href') && value){ send('attr-set', String(value), {tag:this.tagName, attr:name}); } }catch(e){}
          return _setAttr.apply(this, arguments);
        };
        try{ const d=Object.getOwnPropertyDescriptor(HTMLImageElement.prototype,'src'); if(d&&d.set) Object.defineProperty(HTMLImageElement.prototype,'src',{set(v){send('img-src',String(v),{}); return d.set.call(this,v);}, get(){return d.get.call(this);}});}catch(e){}
        try{ const d=Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype,'src'); if(d&&d.set) Object.defineProperty(HTMLIFrameElement.prototype,'src',{set(v){send('iframe-src',String(v),{}); return d.set.call(this,v);}, get(){return d.get.call(this);}});}catch(e){}
        try{ const d=Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype,'src'); if(d&&d.set) Object.defineProperty(HTMLScriptElement.prototype,'src',{set(v){send('script-src',String(v),{}); return d.set.call(this,v);}, get(){return d.get.call(this);}});}catch(e){}
        try{ const d=Object.getOwnPropertyDescriptor(HTMLLinkElement.prototype,'href'); if(d&&d.set) Object.defineProperty(HTMLLinkElement.prototype,'href',{set(v){send('link-href',String(v),{}); return d.set.call(this,v);}, get(){return d.get.call(this);}});}catch(e){}
        const _write = document.write.bind(document), _writeln = document.writeln.bind(document);
        function sniff(args){ try{ const s = Array.from(args).join(''); (s.match(/https?:\\/\\/[^"'>\\s)]+/gi)||[]).forEach(u=>send('doc-url',u,{})); }catch(e){} }
        document.write = function(){ sniff(arguments); return _write.apply(document, arguments); };
        document.writeln = function(){ sniff(arguments); return _writeln.apply(document, arguments); };
        try{
          if('PerformanceObserver' in window){
            const po=new PerformanceObserver(list=>{ list.getEntries().forEach(ent=>{ if(ent && ent.name) send('perf-entry', ent.name, {type:ent.initiatorType}); });});
            po.observe({entryTypes:['resource']});
          }
        }catch(e){ send('perf-error','',{message:e.message}); }
        send('child-hooks-ready', location.href, {});
      })();
    `;

    function instrumentAboutBlankIframe(node) {
      try {
        if (!node || node.tagName !== 'IFRAME') return;
        const src = (node.getAttribute('src') || '').trim();
        if (!src || src === 'about:blank' || src.startsWith('javascript:') || src.startsWith('data:')) {
          let tries = 0;
          (function attempt(){
            tries++;
            try {
              const doc = node.contentDocument || (node.contentWindow && node.contentWindow.document);
              if (doc && doc.documentElement) {
                const s = doc.createElement('script');
                s.textContent = CHILD_HOOKS_JS;
                doc.documentElement.appendChild(s);
                logNetworkActivity('(child-frame)', 'success', 'Injected child iframe hooks');
                return;
              }
            } catch(e) {}
            if (tries < 40) setTimeout(attempt, 50);
          })();
        }
      } catch(e) {
        logNetworkActivity('(child-frame)', 'error', 'Failed to inject child hooks: ' + e.message);
      }
    }

    // ---- Main sandbox runner ----
    function runTagInSandbox(tagContent) {
      const creativeDiv = document.getElementById("creative");

      // Escaped debug view
      const debugDiv = document.createElement('div');
      debugDiv.style.cssText = 'background:#F0F6FF;border:1px solid #0055A4;padding:15px;margin-bottom:15px;border-radius:5px;font-family:monospace;font-size:12px;white-space:pre-wrap;max-height:220px;overflow-y:auto;';
      const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      debugDiv.innerHTML = `<strong>Debug Info:</strong><br><strong>Raw Tag Length:</strong> ${tagContent.length}<br><br><strong>Tag Content (escaped):</strong><br><code>${esc(tagContent)}</code>`;
      creativeDiv.appendChild(debugDiv);

      const wrapper = document.createElement('div');
      wrapper.style.cssText = 'border:2px dashed #0055A4;padding:10px;margin-top:10px;border-radius:8px;';
      wrapper.innerHTML = '<strong>CM360 Creative Sandbox:</strong><br><br>';
      creativeDiv.appendChild(wrapper);

      const iframe = document.createElement('iframe');
      iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups';
      iframe.style.width = '300px'; iframe.style.height = '250px'; iframe.style.border = '1px solid #ccc';
      wrapper.appendChild(iframe);

      // Bootstrap that runs inside the sandbox frame
      const BOOTSTRAP = `
        <script>
          (function(){
            function send(kind, url, extra){ try{ parent.postMessage({kind, url, extra}, '*'); }catch(e){} }
            const _fetch = window.fetch;
            window.fetch = function(...args){
              const u = (args[0] && args[0].url) ? args[0].url : String(args[0]);
              send('fetch-init', u, {}); 
              return _fetch.apply(this, args).then(r=>{ send('fetch-done', u, {status:r.status}); return r; })
                                             .catch(err=>{ send('fetch-error', u, {message:err && err.message}); throw err; });
            };
            const _XHR = window.XMLHttpRequest;
            window.XMLHttpRequest = function(){
              const xhr = new _XHR(); const _open = xhr.open;
              xhr.open = function(method, url, ...rest){ xhr.__u=url; send('xhr-open', url, {method}); return _open.apply(this,[method,url,...rest]); };
              xhr.addEventListener('load', ()=>send('xhr-done', xhr.__u||'', {status:xhr.status}));
              xhr.addEventListener('error',()=>send('xhr-error',xhr.__u||'',{}));
              return xhr;
            };
            if (navigator && navigator.sendBeacon){
              const _b = navigator.sendBeacon.bind(navigator);
              navigator.sendBeacon = function(url, data){ send('beacon', String(url||''), {}); return _b(url, data); };
            }
            const _append = Node.prototype.appendChild;
            Node.prototype.appendChild = function(ch){
              try{
                if(ch && ch.tagName){
                  const u = ch.src || ch.href || '';
                  if (u) send('dom-append', u, {tag: ch.tagName});
                  if (ch.tagName === 'IFRAME') { send('child-iframe', u||'(blank)', {}); }
                }
              }catch(e){}
              return _append.call(this, ch);
            };
            try{
              const mo = new MutationObserver(muts=>{
                muts.forEach(m=>{
                  if(m.type==='attributes' && (m.attributeName==='src'||m.attributeName==='href')){
                    const n=m.target; const u=n.src||n.href||''; 
                    send('attr-change', u, {tag:n.tagName, attr:m.attributeName});
                    if(n.tagName==='IFRAME'){ send('child-iframe', u||'(blank)', {}); }
                  }
                  (m.addedNodes||[]).forEach(n=>{
                    if(n && n.tagName){
                      const u=n.src||n.href||''; send('dom-add', u||'(none)', {tag:n.tagName});
                      if(n.tagName==='IFRAME'){ send('child-iframe', u||'(blank)', {}); }
                    }
                  });
                });
              });
              mo.observe(document.documentElement,{childList:true,subtree:true,attributes:true,attributeFilter:['src','href']});
            }catch(e){ send('mo-error','',{message:e.message}); }
            try{ const d=Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype,'src'); if(d&&d.set) Object.defineProperty(HTMLIFrameElement.prototype,'src',{set(v){ send('iframe-src',String(v),{}); return d.set.call(this,v);},get(){return d.get.call(this);}});}catch(e){}
            try{ const d=Object.getOwnPropertyDescriptor(HTMLImageElement.prototype,'src'); if(d&&d.set) Object.defineProperty(HTMLImageElement.prototype,'src',{set(v){ send('img-src',String(v),{}); return d.set.call(this,v);},get(){return d.get.call(this);}});}catch(e){}
            try{ const d=Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype,'src'); if(d&&d.set) Object.defineProperty(HTMLScriptElement.prototype,'src',{set(v){ send('script-src',String(v),{}); return d.set.call(this,v);},get(){return d.get.call(this);}});}catch(e){}
            try{ const d=Object.getOwnPropertyDescriptor(HTMLLinkElement.prototype,'href'); if(d&&d.set) Object.defineProperty(HTMLLinkElement.prototype,'href',{set(v){ send('link-href',String(v),{}); return d.set.call(this,v);},get(){return d.get.call(this);}});}catch(e){}
            const _w = document.write.bind(document), _wl = document.writeln.bind(document);
            function sniff(args){ try{ const s=Array.from(args).join(''); (s.match(/https?:\\/\\/[^"'>\\s)]+/gi)||[]).forEach(u=>send('doc-url',u,{})); }catch(e){} }
            document.write   = function(){ sniff(arguments); return _w.apply(document, arguments); };
            document.writeln = function(){ sniff(arguments); return _wl.apply(document, arguments); };
            try{
              if('PerformanceObserver' in window){
                const po=new PerformanceObserver(list=>{ list.getEntries().forEach(ent=>{ if(ent && ent.name) send('perf-entry', ent.name, {type:ent.initiatorType});});});
                po.observe({entryTypes:['resource']});
              }
            }catch(e){ send('perf-error','',{message:e.message}); }
            send('bootstrap-ready', location.href, {});
          })();
        <\/script>
      `;

      iframe.srcdoc = `
        <!doctype html>
        <html><head><meta charset="utf-8"><style>body{margin:0}.dcmads{display:block!important}</style></head>
        <body>
          ${BOOTSTRAP}
          <div id="tag-container">${tagContent}</div>
        </body></html>
      `;

      iframe.onload  = () => { logNetworkActivity('sandbox','success','Sandbox iframe loaded'); wrapper.style.border='2px solid #4CAF50'; wrapper.querySelector('strong').textContent='CM360 Creative Sandbox (Loaded):'; };
      iframe.onerror = () => { logNetworkActivity('sandbox','error','Sandbox iframe failed to load'); wrapper.style.border='2px solid #F44336'; wrapper.querySelector('strong').textContent='CM360 Creative Sandbox (Error):'; };

      // When the sandbox tells us an iframe was added/changed, try to inject hooks if it's about:blank
      window.addEventListener('message', (evt)=>{
        const d = evt.data || {};
        if (d && d.kind === 'child-iframe') {
          try {
            const doc = iframe.contentDocument;
            if (!doc) return;
            const frames = Array.from(doc.querySelectorAll('iframe'));
            frames.forEach(f => instrumentAboutBlankIframe(f));
          } catch(e){}
        }
      });
    }

    // ---- Receive sandbox & child-frame events ----
    window.addEventListener('message', (evt) => {
      const d = evt.data || {}; if (!d || !d.kind) return;
      const labelMap = {
        'fetch-init':'Fetch request initiated','fetch-done':'Fetch request completed','fetch-error':'Fetch request failed',
        'xhr-open':'XHR request opened','xhr-done':'XHR request completed','xhr-error':'XHR request failed',
        'beacon':'Beacon sent',
        'dom-append':'Element appended','img-src':'Image src set','iframe-src':'Iframe src set',
        'script-src':'Script src set','link-href':'Link href set','attr-set':'Attribute set',
        'attr-change':'Attribute changed','dom-add':'Element added','nested-element':'Nested element detected',
        'doc-url':'URL found in document.write','perf-entry':'Resource performance entry',
        'mo-error':'MutationObserver error','perf-error':'PerformanceObserver error',
        'bootstrap-ready':'Sandbox ready','child-hooks-ready':'Child iframe ready','child-iframe':'Child iframe noticed'
      };
      const status = /error/i.test(d.kind) ? 'error' : 'success';
      logNetworkActivity(d.url || '(unknown)', status, `[Sandbox] ${labelMap[d.kind] || d.kind}`);
    });

    // === Extension bridge: receive network events across subframes ===
    (function () {
      const badge = document.createElement('div');
      badge.style.cssText = 'position:fixed;right:12px;bottom:12px;padding:6px 10px;border-radius:6px;background:#0055A4;color:#fff;font:12px/1.2 sans-serif;z-index:99999;opacity:.9';
      badge.textContent = 'Pixel Ext: waiting‚Ä¶';
      document.body.appendChild(badge);

      window.addEventListener('message', (evt) => {
        const msg = evt.data;
        if (!msg || msg.source !== 'cm360-pixel-ext') return;

        if (msg.kind === 'hello') {
          badge.textContent = 'Pixel Ext: connected';
          return;
        }
        if (msg.kind === 'net') {
          const { url, phase, statusCode, method, type, frameId } = msg.payload || {};
          const status = (phase === 'error' || (statusCode && statusCode >= 400)) ? 'error' : 'success';
          const desc = `[Ext][${type || 'request'}][f:${frameId}] ${method || ''} ${phase}${statusCode ? ' (' + statusCode + ')' : ''}`;
          logNetworkActivity(url || '(unknown)', status, desc);
        }
      });
    })();

    // === ID PARSER (tag + network URLs) ===
    const idState = {
      placementId: null,
      adId: null,
      creativeId: null,
      notes: []
    };

    function setIdValue(elId, val) {
      const el = document.getElementById(elId);
      if (!el) return;
      el.textContent = val || '';
    }

    function copyText(elId) {
      const el = document.getElementById(elId);
      if (!el) return;
      const txt = el.textContent || '';
      if (!txt) return;
      navigator.clipboard?.writeText(txt);
    }
    window.copyText = copyText;

    function note(msg) { idState.notes.push(msg); renderIdNotes(); }
    function renderIdNotes() {
      const el = document.getElementById('idParserNotes');
      if (!el) return;
      el.innerHTML = idState.notes.map(n => `‚Ä¢ ${n}`).join('<br>');
    }

    function tryAssign(targetKey, val, reason) {
      if (!val) return;
      if (!idState[targetKey]) {
        idState[targetKey] = val;
        note(`${targetKey} = ${val} (${reason})`);
        if (targetKey === 'placementId') setIdValue('placementIdValue', val);
        if (targetKey === 'adId') setIdValue('adIdValue', val);
        if (targetKey === 'creativeId') setIdValue('creativeIdValue', val);
      }
    }

    function parseQuery(url) {
      try { const u = new URL(url, location.href); return Object.fromEntries(u.searchParams.entries()); }
      catch { return {}; }
    }

    // Heuristics: CM360 often exposes ad/creative/placement via params like
    // adid, ad, ad_id | crid, creative, creativeid | placementid, plid
    function extractIdsFromUrl(url) {
      const q = parseQuery(url);
      const keys = Object.keys(q).reduce((acc, k) => { acc[k.toLowerCase()] = q[k]; return acc; }, {});
      const get = (...names) => {
        for (const n of names) { if (keys[n] && String(keys[n]).trim()) return String(keys[n]).trim(); }
        return null;
      };
      const ad = get('adid','ad','ad_id');
      const cr = get('crid','creative','creativeid','cid');
      const pl = get('placementid','plid','placement','plc');
      return { ad, cr, pl };
    }

    // Try to sniff a numeric-looking ID from text (e.g., "Placement ID: 426439465")
    function sniffNumericIdFromText(s, labelRx) {
      const rx = new RegExp(labelRx + '\\s*[:=]\\s*(\\d{5,})','i');
      const m = s.match(rx);
      return m ? m[1] : null;
    }

    // Fallback: find long numeric tokens that look ID-ish
    function sniffAnyIdNumbers(s, minLen = 7) {
      const out = [];
      (s.match(/(^|[^0-9])(\\d{7,})(?![0-9])/g) || []).forEach(tok => {
        const n = tok.replace(/\\D/g,'');
        if (n && n.length >= minLen) out.push(n);
      });
      return out;
    }

    function tryParseIdsFromRawTag(tagContent) {
      // Direct label-based
      tryAssign('placementId', sniffNumericIdFromText(tagContent, 'placement\\s*id'), 'raw tag text');
      tryAssign('adId', sniffNumericIdFromText(tagContent, 'ad\\s*id'), 'raw tag text');
      tryAssign('creativeId', sniffNumericIdFromText(tagContent, 'creative\\s*id'), 'raw tag text');

      // URL param-based inside the tag
      const urls = tagContent.match(/https?:\\/\\/[^"'>\\s)]+/gi) || [];
      urls.forEach(u => {
        const { ad, cr, pl } = extractIdsFromUrl(u);
        tryAssign('adId', ad, `URL param in tag (${u})`);
        tryAssign('creativeId', cr, `URL param in tag (${u})`);
        tryAssign('placementId', pl, `URL param in tag (${u})`);
      });

      // As last resort, use any big numbers if nothing else hit
      if (!idState.placementId || !idState.adId || !idState.creativeId) {
        const bigs = sniffAnyIdNumbers(tagContent);
        if (bigs.length) note(`Found numeric tokens in tag: ${bigs.slice(0,3).join(', ')}‚Ä¶`);
      }
    }

    function tryParseIdsFromUrl(u) {
      if (!u || u === '(unknown)' || u === '(none)') return;
      const { ad, cr, pl } = extractIdsFromUrl(u);
      tryAssign('adId', ad, `URL param (${u})`);
      tryAssign('creativeId', cr, `URL param (${u})`);
      tryAssign('placementId', pl, `URL param (${u})`);
    }

    // ---- Boot ----
    initializePixelTracking();
    const rawTag = decodeURIComponent(params.get("tag") || "");
    const header = document.createElement('div');
    header.style.cssText = 'background:#E6F0FA;border:1px solid #0055A4;padding:12px;border-radius:6px;margin-bottom:15px;font-weight:600;';
    header.textContent = params.get("tag") ? '‚úÖ Tag parameter detected - initializing sandbox...' : '‚ùå No tag parameter found in URL.';
    document.getElementById("creative").appendChild(header);

    // Start capture window and finalize logic
    function finalizeCapture(reason) {
      // Flip any still-pending pixels to not-fired
      expectedPixels.forEach(pixel => {
        if (pixelStatus[pixel.name] === 'pending') {
          pixelStatus[pixel.name] = 'not-fired';
          const el = document.getElementById(`pixel-${pixel.name.replace(/[^a-zA-Z0-9]/g, '')}`);
          if (el) { el.className = "pixel-check not-fired"; el.textContent = `‚ùå ${pixel.name}: Timeout (no activity detected)`; }
        }
      });
      updateStats();
      logNetworkActivity('finalize', reason === 'idle' ? 'success' : 'error', reason === 'idle' ? 'Capture ended (idle)' : 'Capture ended (timeout)');
    }

    if (rawTag && rawTag.trim()) {
      expectedPixels.forEach(p => markPixelPending(p.name)); // pending immediately

      // Parse IDs from the raw tag before running
      tryParseIdsFromRawTag(rawTag);

      // Run sandbox
      runTagInSandbox(rawTag);

      // Start extended capture window (defaults to 60s; override with ?extraMs=‚Ä¶)
      startCaptureWindow(finalizeCapture);
    } else {
      document.getElementById("creative").innerHTML += "<p style='color:#C9302C; text-align:center; padding:20px;'>‚ùå No tag content received or tag is empty.</p>";
    }
  </script>
</body>
</html>
