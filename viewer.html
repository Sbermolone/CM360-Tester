<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CM360 Tag Viewer</title>
  <link href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Segoe UI', sans-serif; margin: 0; display: flex; height: 100vh; background: linear-gradient(135deg, #E6F0FA 0%, #F0F6FF 100%); color: #0A1E3F; }
    #leftPanel { width: 50%; height: 100%; padding: 15px; border-right: 2px solid #0055A4; overflow: auto; display: flex; flex-direction: column; background-color: #ffffff; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
    #creative { flex: 1; border: 1px solid #0055A4; border-radius: 8px; padding: 10px; background-color: #F0F6FF; overflow: auto; }
    #log { width: 50%; height: 100%; padding: 20px; background-color: #F0F6FF; overflow-y: auto; }
    h3 { margin-top: 0; color: #0055A4; font-weight: 600; font-size: 1.4em; margin-bottom: 20px; }
    .pixel-check { font-size: 14px; margin: 8px 0; padding: 8px 12px; border-radius: 6px; border-left: 4px solid; background-color: #ffffff; }
    .fired { color: #2E7D32; font-weight: 600; border-left-color: #4CAF50; background-color: #E8F5E8; }
    .not-fired { color: #C9302C; border-left-color: #F44336; background-color: #FFEBEE; }
    .pending { color: #FF9800; border-left-color: #FF9800; background-color: #FFF3E0; }
    #backButton { margin-bottom: 12px; padding: 12px 24px; font-size: 14px; cursor: pointer; border: none; border-radius: 8px; background: linear-gradient(135deg, #0055A4 0%, #007ACC 100%); color: #fff; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0, 85, 164, 0.3); }
    #backButton:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0, 85, 164, 0.4); }
    .stats { background-color: #ffffff; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #0055A4; }
    .stats-item { display: inline-block; margin-right: 20px; font-weight: 600; }
    .fired-count { color: #2E7D32; } .pending-count { color: #FF9800; } .not-fired-count { color: #C9302C; }
    .network-log { max-height: 260px; overflow-y: auto; background-color: #ffffff; border: 1px solid #0055A4; border-radius: 8px; padding: 10px; margin-top: 20px; font-family: monospace; font-size: 12px; }
    .network-entry { margin: 2px 0; padding: 2px 4px; border-radius: 3px; }
    .network-success { background-color: #E8F5E8; } .network-error { background-color: #FFEBEE; }
    .network-pixel { background-color: #FFF3E0; border: 1px solid #FF9800; }
    .clear-btn { background: none; border: 1px solid #0055A4; color: #0055A4; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer; margin-top: 10px; }
    .clear-btn:hover { background-color: #0055A4; color: white; }
  </style>
</head>
<body>
  <div id="leftPanel">
    <button id="backButton" onclick="goBack()">‚Üê Back to Index</button>
    <div id="creative"></div>
  </div>
  <div id="log">
    <h3>Pixel Tracker</h3>
    <div class="stats">
      <span class="stats-item fired-count">‚úÖ Fired: <span id="firedCount">0</span></span>
      <span class="stats-item pending-count">‚è≥ Pending: <span id="pendingCount">0</span></span>
      <span class="stats-item not-fired-count">‚ùå Not Detected: <span id="notFiredCount">0</span></span>
    </div>
    <div id="pixelList"></div>

    <h3>Network Activity</h3>
    <button class="clear-btn" onclick="clearNetworkLog()">Clear Log</button>
    <div id="networkLog" class="network-log"></div>
  </div>

  <script>
    // Keep your vendor list as in your file
    const expectedPixels = [
      { name: "CM360/DoubleClick", patterns: ["doubleclick.net", "googleadservices.com", "googlesyndication.com", "dcmads.js", "fls.doubleclick.net"] },
      { name: "LiveRamp", patterns: ["rlcdn.com", "liveramp.com", "ats-sb.lp4.io", "ramp.com"] },
      { name: "Connect", patterns: ["hrzn-nxt.com", "horizon-nxt.com"] },
      { name: "Meta/Facebook", patterns: ["facebook.com/tr", "connect.facebook.net"] },
      { name: "Google Ads", patterns: ["googleads.g.doubleclick.net", "google-analytics.com", "googletagmanager.com"] },
      { name: "DoubleVerify", patterns: ["doubleverify.com", "dvtps.com", "adsafeprotected.com"] },
      { name: "iSpot", patterns: ["ispot.tv", "px.ispot.tv"] },
      { name: "Generic Pixel", patterns: [".gif", ".png", ".jpg", "pixel", "tracking"] }
    ];

    const pixelStatus = {};
    const networkLog = [];
    let networkLogElement, pixelListElement;

    function initializePixelTracking() {
      pixelListElement = document.getElementById("pixelList");
      networkLogElement = document.getElementById("networkLog");
      expectedPixels.forEach(pixel => {
        pixelStatus[pixel.name] = 'not-fired';
        const el = document.createElement("div");
        el.className = "pixel-check not-fired";
        el.id = `pixel-${pixel.name.replace(/[^a-zA-Z0-9]/g, '')}`;
        el.textContent = `‚ùå ${pixel.name}: Not detected`;
        pixelListElement.appendChild(el);
      });
      updateStats();
    }

    function markPixelFired(name, url) {
      if (pixelStatus[name] !== 'fired') {
        pixelStatus[name] = 'fired';
        const el = document.getElementById(`pixel-${name.replace(/[^a-zA-Z0-9]/g, '')}`);
        if (el) { el.className = "pixel-check fired"; el.textContent = `‚úÖ ${name}: Detected`; }
        logPixelDetection(name, url);
        updateStats();
      }
    }

    function markPixelPending(name) {
      if (pixelStatus[name] === 'not-fired') {
        pixelStatus[name] = 'pending';
        const el = document.getElementById(`pixel-${name.replace(/[^a-zA-Z0-9]/g, '')}`);
        if (el) { el.className = "pixel-check pending"; el.textContent = `‚è≥ ${name}: Loading...`; }
        updateStats();
      }
    }

    function updateStats() {
      const vals = Object.values(pixelStatus);
      document.getElementById('firedCount').textContent = vals.filter(s => s === 'fired').length;
      document.getElementById('pendingCount').textContent = vals.filter(s => s === 'pending').length;
      document.getElementById('notFiredCount').textContent = vals.filter(s => s === 'not-fired').length;
    }

    function logNetworkActivity(url, status, description) {
      const timestamp = new Date().toLocaleTimeString();
      networkLog.push({ timestamp, url, status, description });
      const logEntry = document.createElement('div');
      logEntry.className = `network-entry network-${status}`;
      logEntry.textContent = `[${timestamp}] ${description}: ${url}`;
      networkLogElement.appendChild(logEntry);
      networkLogElement.scrollTop = networkLogElement.scrollHeight;
      setTimeout(() => checkPixelUrl(url), 0); // detect after logging
    }

    function logPixelDetection(name, url) {
      const timestamp = new Date().toLocaleTimeString();
      networkLog.push({ timestamp, url, status: 'pixel', description: `${name} PIXEL FIRED` });
      const logEntry = document.createElement('div');
      logEntry.className = 'network-entry network-pixel';
      logEntry.textContent = `[${timestamp}] üéØ ${name} PIXEL FIRED: ${url}`;
      networkLogElement.appendChild(logEntry);
      networkLogElement.scrollTop = networkLogElement.scrollHeight;
    }

    function clearNetworkLog() { networkLog.length = 0; networkLogElement.innerHTML = ''; }

    // Hostname-aware, case-insensitive matching (no vendor list changes needed)
    function checkPixelUrl(url) {
      if (!url || typeof url !== 'string') return;
      let full = "", host = "";
      try {
        const u = new URL(url, window.location.href);
        full = u.href.toLowerCase();
        host = u.hostname.toLowerCase();
      } catch { full = String(url).toLowerCase(); }
      expectedPixels.forEach(pixel => {
        const hit = pixel.patterns.some(pat => {
          const p = String(pat).toLowerCase().trim();
          if (p.includes(".") && !p.startsWith("/") && host) { // domain-like
            if (host === p || host.endsWith("." + p)) return true;
          }
          return full.includes(p); // fallback substring
        });
        if (hit) markPixelFired(pixel.name, url);
      });
    }

    function goBack() { window.location.href = "index.html"; }
    window.goBack = goBack;

    // Run tag inside a sandboxed iframe with deep instrumentation
    function runTagInSandbox(tagContent) {
      const creativeDiv = document.getElementById("creative");

      // Escaped debug view
      const debugDiv = document.createElement('div');
      debugDiv.style.cssText = 'background:#F0F6FF;border:1px solid #0055A4;padding:15px;margin-bottom:15px;border-radius:5px;font-family:monospace;font-size:12px;white-space:pre-wrap;max-height:220px;overflow-y:auto;';
      const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      debugDiv.innerHTML = `<strong>Debug Info:</strong><br><strong>Raw Tag Length:</strong> ${tagContent.length}<br><br><strong>Tag Content (escaped):</strong><br><code>${esc(tagContent)}</code>`;
      creativeDiv.appendChild(debugDiv);

      const wrapper = document.createElement('div');
      wrapper.style.cssText = 'border:2px dashed #0055A4;padding:10px;margin-top:10px;border-radius:8px;';
      wrapper.innerHTML = '<strong>CM360 Creative Sandbox:</strong><br><br>';
      creativeDiv.appendChild(wrapper);

      const iframe = document.createElement('iframe');
      iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups';
      iframe.style.width = '300px'; iframe.style.height = '250px'; iframe.style.border = '1px solid #ccc';
      wrapper.appendChild(iframe);

      // Bootstrap that runs inside the iframe and reports back
      const bootstrap = `
        <script>
          (function() {
            function send(kind, url, extra) { try { parent.postMessage({kind, url, extra}, '*'); } catch(e) {} }

            // fetch
            const _fetch = window.fetch;
            window.fetch = function(...args) {
              const url = (args[0] && args[0].url) ? args[0].url : String(args[0]);
              send('fetch-init', url, {});
              return _fetch.apply(this, args).then(r => { send('fetch-done', url, {status:r.status}); return r; })
                                           .catch(err => { send('fetch-error', url, {message:err && err.message}); throw err; });
            };

            // XHR
            const _XHR = window.XMLHttpRequest;
            window.XMLHttpRequest = function() {
              const xhr = new _XHR(); const _open = xhr.open;
              xhr.open = function(method, url, ...rest) { xhr.__mon_url = url; send('xhr-open', url, {method}); return _open.apply(this, [method, url, ...rest]); };
              xhr.addEventListener('load',  () => send('xhr-done',  xhr.__mon_url || '', {status:xhr.status}));
              xhr.addEventListener('error', () => send('xhr-error', xhr.__mon_url || '', {}));
              return xhr;
            };

            // sendBeacon (used by some vendors)
            if (navigator && navigator.sendBeacon) {
              const _beacon = navigator.sendBeacon.bind(navigator);
              navigator.sendBeacon = function(url, data) { send('beacon', String(url||''), {}); return _beacon(url, data); };
            }

            // appendChild
            const _append = Node.prototype.appendChild;
            Node.prototype.appendChild = function(child) {
              try { if (child && child.tagName) { const u = child.src || child.href || ''; if (u) send('dom-append', u, {tag: child.tagName}); } } catch(e){}
              return _append.call(this, child);
            };

            // setAttribute for src/href
            const _setAttr = Element.prototype.setAttribute;
            Element.prototype.setAttribute = function(name, value) {
              try { if ((name === 'src' || name === 'href') && value) { send('attr-set', String(value), {tag:this.tagName, attr:name}); } } catch(e){}
              return _setAttr.apply(this, arguments);
            };

            // property setters (img/src, iframe/src, script/src, link/href)
            try {
              const dImg = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src');
              if (dImg && dImg.set) Object.defineProperty(HTMLImageElement.prototype, 'src', { set(v){ send('img-src', String(v), {}); return dImg.set.call(this, v); }, get(){ return dImg.get.call(this); } });
            } catch(e){}
            try {
              const dIf = Object.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'src');
              if (dIf && dIf.set) Object.defineProperty(HTMLIFrameElement.prototype, 'src', { set(v){ send('iframe-src', String(v), {}); return dIf.set.call(this, v); }, get(){ return dIf.get.call(this); } });
            } catch(e){}
            try {
              const dSc = Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src');
              if (dSc && dSc.set) Object.defineProperty(HTMLScriptElement.prototype, 'src', { set(v){ send('script-src', String(v), {}); return dSc.set.call(this, v); }, get(){ return dSc.get.call(this); } });
            } catch(e){}
            try {
              const dLk = Object.getOwnPropertyDescriptor(HTMLLinkElement.prototype, 'href');
              if (dLk && dLk.set) Object.defineProperty(HTMLLinkElement.prototype, 'href', { set(v){ send('link-href', String(v), {}); return dLk.set.call(this, v); }, get(){ return dLk.get.call(this); } });
            } catch(e){}

            // document.write / writeln (log embedded URLs)
            const _write = document.write.bind(document);
            const _writeln = document.writeln.bind(document);
            function logStrings(args){ try { const s = Array.from(args).join(''); const urls = s.match(/https?:\\/\\/[^"'>\\s)]+/gi) || []; urls.forEach(u => send('doc-url', u, {})); } catch(e){} }
            document.write = function(){ logStrings(arguments); return _write.apply(document, arguments); };
            document.writeln = function(){ logStrings(arguments); return _writeln.apply(document, arguments); };

            // MutationObserver (added nodes + src/href changes)
            try {
              const mo = new MutationObserver(muts => {
                muts.forEach(m => {
                  if (m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'href')) {
                    const n = m.target; const url = n.src || n.href || ''; if (url) send('attr-change', url, {tag: n.tagName, attr: m.attributeName});
                  }
                  (m.addedNodes || []).forEach(n => {
                    if (n && n.tagName) {
                      const url = n.src || n.href || ''; if (url) send('dom-add', url, {tag: n.tagName});
                      if (n.querySelectorAll) {
                        n.querySelectorAll('[src],[href]').forEach(nn => { const u = nn.src || nn.href || ''; if (u) send('nested-element', u, {tag: nn.tagName}); });
                      }
                    }
                  });
                });
              });
              mo.observe(document.documentElement, { childList:true, subtree:true, attributes:true, attributeFilter:['src','href'] });
            } catch(e){ send('mo-error','',{message:e.message}); }

            // PerformanceObserver (resource-level events for this frame)
            try {
              if ('PerformanceObserver' in window) {
                const po = new PerformanceObserver(list => {
                  list.getEntries().forEach(ent => { if (ent && ent.name) send('perf-entry', ent.name, {type: ent.initiatorType, duration: ent.duration}); });
                });
                po.observe({ entryTypes: ['resource'] });
              }
            } catch(e){ send('perf-error','',{message:e.message}); }

            send('bootstrap-ready', location.href, {});
          })();
        <\/script>
      `;

      iframe.srcdoc = `
        <!doctype html>
        <html><head><meta charset="utf-8"><style>body{margin:0}.dcmads{display:block!important}</style></head>
        <body>
          ${bootstrap}
          <div id="tag-container">${tagContent}</div>
        </body></html>
      `;

      iframe.onload  = () => { logNetworkActivity('sandbox','success','Sandbox iframe loaded'); wrapper.style.border='2px solid #4CAF50'; wrapper.querySelector('strong').textContent='CM360 Creative Sandbox (Loaded):'; };
      iframe.onerror = () => { logNetworkActivity('sandbox','error','Sandbox iframe failed to load'); wrapper.style.border='2px solid #F44336'; wrapper.querySelector('strong').textContent='CM360 Creative Sandbox (Error):'; };
    }

    // Receive sandbox events (these feed into checkPixelUrl via logNetworkActivity)
    window.addEventListener('message', (evt) => {
      const d = evt.data || {}; if (!d || !d.kind) return;
      const labelMap = {
        'fetch-init':'Fetch request initiated','fetch-done':'Fetch request completed','fetch-error':'Fetch request failed',
        'xhr-open':'XHR request opened','xhr-done':'XHR request completed','xhr-error':'XHR request failed',
        'beacon':'Beacon sent',
        'dom-append':'Element appended','img-src':'Image src set','iframe-src':'Iframe src set',
        'script-src':'Script src set','link-href':'Link href set','attr-set':'Attribute set',
        'attr-change':'Attribute changed','dom-add':'Element added','nested-element':'Nested element detected',
        'doc-url':'URL found in document.write','perf-entry':'Resource performance entry',
        'mo-error':'MutationObserver error','perf-error':'PerformanceObserver error','bootstrap-ready':'Sandbox ready'
      };
      const status = /error/i.test(d.kind) ? 'error' : 'success';
      logNetworkActivity(d.url || '(unknown)', status, `[Sandbox] ${labelMap[d.kind] || d.kind}`);
    });

    // Boot
    initializePixelTracking();
    const params = new URLSearchParams(window.location.search);
    const rawTag = decodeURIComponent(params.get("tag") || "");
    const header = document.createElement('div');
    header.style.cssText = 'background:#E6F0FA;border:1px solid #0055A4;padding:12px;border-radius:6px;margin-bottom:15px;font-weight:600;';
    header.textContent = params.get("tag") ? '‚úÖ Tag parameter detected - initializing sandbox...' : '‚ùå No tag parameter found in URL.';
    document.getElementById("creative").appendChild(header);

    if (rawTag && rawTag.trim()) {
      expectedPixels.forEach(p => markPixelPending(p.name));     // show ‚Äúpending‚Äù immediately
      runTagInSandbox(rawTag);
      setTimeout(() => {                                         // fallback timeout
        expectedPixels.forEach(pixel => {
          if (pixelStatus[pixel.name] === 'pending') {
            pixelStatus[pixel.name] = 'not-fired';
            const el = document.getElementById(`pixel-${pixel.name.replace(/[^a-zA-Z0-9]/g, '')}`);
            if (el) { el.className = "pixel-check not-fired"; el.textContent = `‚ùå ${pixel.name}: Timeout (no activity detected)`; }
          }
        });
        updateStats();
        logNetworkActivity('timeout','error','Pixel detection timeout reached');
      }, 12000);
    } else {
      document.getElementById("creative").innerHTML += "<p style='color:#C9302C; text-align:center; padding:20px;'>‚ùå No tag content received or tag is empty.</p>";
    }
  </script>
</body>
</html>
